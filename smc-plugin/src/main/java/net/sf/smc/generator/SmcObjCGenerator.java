//
// The contents of this file are subject to the Mozilla Public
// License Version 1.1 (the "License"); you may not use this file
// except in compliance with the License. You may obtain a copy
// of the License at http://www.mozilla.org/MPL/
//
// Software distributed under the License is distributed on an
// "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
// implied. See the License for the specific language governing
// rights and limitations under the License.
//
// The Original Code is State Machine Compiler (SMC).
//
// The Initial Developer of the Original Code is Charles W. Rapp.
// Portions created by Charles W. Rapp are
// Copyright (C) 2006 - 2009. Charles W. Rapp.
// All Rights Reserved.
//
// Contributor(s):
//   Eitan Suez contributed examples/Ant.
//   (Name withheld) contributed the C# code generation and
//   examples/C#.
//   Francois Perrad contributed the Python code generation and
//   examples/Python.
//   Chris Liscio contributed the Objective-C code generation
//   and examples/ObjC.
//
// RCS ID
// $Id: SmcObjCGenerator.java,v 1.11 2011/11/20 14:58:33 cwrapp Exp $
//
// CHANGE LOG
// (See the bottom of this file.)
//

package net.sf.smc.generator;

import java.io.PrintStream;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;
import net.sf.smc.model.SmcAction;
import net.sf.smc.model.SmcElement;
import net.sf.smc.model.SmcElement.TransType;
import net.sf.smc.model.SmcFSM;
import net.sf.smc.model.SmcGuard;
import net.sf.smc.model.SmcMap;
import net.sf.smc.model.SmcParameter;
import net.sf.smc.model.SmcState;
import net.sf.smc.model.SmcTransition;
import net.sf.smc.model.SmcVisitor;

/**
 * Visits the abstract syntax tree emitting Objective-C code.
 * @see SmcElement
 * @see SmcCodeGenerator
 * @see SmcVisitor
 * @see SmcOptions
 *
 * @author Chris Liscio
 */

public final class SmcObjCGenerator
    extends SmcCodeGenerator
{
//---------------------------------------------------------------
// Member methods
//

    //-----------------------------------------------------------
    // Constructors.
    //

    /**
     * Creates a Objective C code generator for the given
     * options.
     * @param options The target code generator options.
     */
    public SmcObjCGenerator(final SmcOptions options)
    {
        super (options, "m");
    } // end of SmcObjCGenerator(SmcOptions)

    //
    // end of Constructors.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // SmcVisitor Abstract Method Impelementation.
    //

    /**
     * Emits Objective C code for the finite state machine.
     * Generates the following code:
     * <code>
     *   <pre>
     * %{ %} raw source code - if any
     *
     * #import <i>%include header file</i>
     * #import "<i>context</i>.h"
     *   </pre>
     * </code>
     * @param fsm emit Objective C code for this finite state
     * machine.
     */
    public void visit(SmcFSM fsm)
    {
        String packageName = fsm.getPackage();
        String rawSource = fsm.getSource();
        String context = fsm.getContext();
        String fsmClassName = fsm.getFsmClassName();
        String fqStateName = fsm.getStartState();
        String mapName;
        List<SmcTransition> transList;
        String separator;
        List<SmcParameter> params;
        Iterator<SmcMap> mapIt;
        SmcMap map;
        Iterator<SmcState> stateIt;
        SmcState state;
        Iterator<SmcParameter> pit;
        String declaration;
        int packageDepth = 0;
        int index;

        _source.println("/*");
        _source.println(" * ex: set ro:");
        _source.println(" * DO NOT EDIT.");
        _source.println(" * generated by smc (http://smc.sourceforge.net/)");
        _source.print(" * from file : ");
        _source.print(_srcfileBase);
        _source.println(".sm");
        _source.println(" */");
        _source.println();

        // Dump out the raw source code, if any.
        if (rawSource != null && rawSource.length() > 0)
        {
            _source.println(rawSource);
            _source.println();
        }

        // Generate #imports.
        for (String include: fsm.getIncludes())
        {
            _source.print("#import ");
            _source.println(include);
        }

        // Include the context file last.
        _source.print("#import \"");
        _source.print(_targetfileBase);
        _source.println(".h\"");

        // Statically declare all derive state classes.
        _source.print(_indent);
        _source.println("// Class declarations.");
		
        for (mapIt = fsm.getMaps().iterator(), index = 0;
             mapIt.hasNext() == true;
            )
        {
            map = mapIt.next();
            mapName = map.getName();

            _source.print(_indent);
            _source.print("@implementation ");
            _source.println(mapName);

			// add static members			
            for (stateIt = map.getStates().iterator();
                 stateIt.hasNext() == true;
                 )
            {
                state = stateIt.next();

                _source.print(_indent);
                _source.print("    ");
                _source.print("static ");
                _source.print(mapName);
                _source.print("_");
                _source.print(state.getClassName());
                _source.print(" *g");
                _source.print(mapName);
                _source.print("_");
                _source.print(state.getClassName());
                _source.println(" = nil;");
			}
			_source.println();
				
			// add methods
            for (stateIt = map.getStates().iterator();
                 stateIt.hasNext() == true;
                 )
            {
                state = stateIt.next();
                _source.print(_indent);
                _source.print("+ (");
                _source.print(mapName);
                _source.print("_");
                _source.print(state.getClassName());
                _source.print("*)");
                _source.print(state.getInstanceName());
                _source.println(";");

                _source.print(_indent);
                _source.println("{");

                _source.print(_indent);
                _source.print("    if (!g");
                _source.print(mapName);
                _source.print("_");
                _source.print(state.getClassName());
                _source.println(")");
                _source.print(_indent);
                _source.println("    {");

                _source.print(_indent);
                _source.print("        g");
                _source.print(mapName);
                _source.print("_");
                _source.print(state.getClassName());
                _source.print(" = [[");
                _source.print(mapName);
                _source.print("_");
                _source.print(state.getClassName());
                _source.print(" alloc] initWithName:@\"");
                _source.print(mapName);
                _source.print("::");
                _source.print(state.getClassName());
                _source.print("\" stateId:");
                _source.print(index);
                _source.println("];");

                _source.print(_indent);
                _source.println("    }");

                _source.print(_indent);
                _source.print("    ");
                _source.print("return g");
                _source.print(mapName);
                _source.print("_");
                _source.print(state.getClassName());
                _source.println(";");

                _source.print(_indent);
                _source.println("}");
                _source.println();
            }

			// add cleanup
			_source.print(_indent);
			_source.println("+ (void) cleanupStates");
			_source.print(_indent);
			_source.println("{");
			
			// cleanup content
            for (stateIt = map.getStates().iterator();
                 stateIt.hasNext() == true;
                 ++index)
            {
                state = stateIt.next();

				_source.print(_indent);
                _source.print("    ");
				_source.print("[g");
                _source.print(mapName);
                _source.print("_");
                _source.print(state.getClassName());
				_source.print(" release]; g");
                _source.print(mapName);
                _source.print("_");
                _source.print(state.getClassName());
				_source.println(" = nil;");
			}

			_source.print(_indent);
			_source.println("}");
				
            _source.println("@end");
        }

        // Print out the default definitions for all the
        // transitions. First, get the transitions list.
        transList = fsm.getTransitions();

        _source.println();
        _source.print(_indent);
        _source.print("@implementation ");
        _source.print(context);
        _source.println("State");

        // TODO: Need to fill in Entry/Exit code if they're
        // defined
        _source.print(_indent);
        _source.print("- (void)Entry:(");
        _source.print(fsmClassName);
        _source.println("*)context");
        _source.print(_indent);
        _source.println("{");
        _source.print(_indent);
        _source.println("}");

        _source.print(_indent);
        _source.print("- (void)Exit:(");
        _source.print(fsmClassName);
        _source.println("*)context");
        _source.print(_indent);
        _source.println("{");
        _source.print(_indent);
        _source.println("}");

        // Output the default transition definitions.
        for (SmcTransition trans: transList)
        {
            if (trans.getName().equals("Default") == false)
            {
                _source.print(_indent);
                _source.print("- (void)");
                _source.print(trans.getName());
                _source.print(":(");
                _source.print(fsmClassName);
                _source.print("*)context");

                for (SmcParameter param: trans.getParameters())
                {
                    _source.print(" :");
                    param.accept(this);
                }

                _source.println(";");
                _source.print(_indent);
                _source.println("{");
                _source.print(_indent);
                _source.println("    [self Default:context];");
                _source.print(_indent);
                _source.println("}");
            }
        }

        // Output the Default transition method ... almost.
        // If -g is being used, then add the "s" argname.
        _source.println();
        _source.print(_indent);
        _source.print("- (void)Default:(");
        _source.print(fsmClassName);
        _source.println("*)context;");
        _source.print(_indent);
        _source.println("{");

        // Print the transition out to the verbose log.
        if (_debugLevel >= DEBUG_LEVEL_0)
        {
            _source.print(_indent);
            _source.println("    if ( [context debugFlag] )");
            _source.print(_indent);
            _source.print("{");

            // The TRACE macro.
            _source.print(_indent);
            _source.print("        TRACE(@");
            _source.println(
                "\"TRANSITION   : Default\\n\\r\");");

            _source.print(_indent);
            _source.println("    }");
        }

        // A transition has been issued which has no
        // definition in the current state and there
        // is no default to cover for it. Throw an
        // exception.
        // v. 1.3.1: But only if -noex was not specified.
        _source.print(_indent);
        _source.println(
            "    NSAssert( NO, @\"Default transition\" );");
        _source.print(_indent);
        _source.println("}");

        // End the state class
        _source.println("@end");
        _source.println();

        // Have each map print out its source code now.
        for (mapIt = fsm.getMaps().iterator();
             mapIt.hasNext() == true;
            )
        {
            (mapIt.next()).accept(this);
        }

        // Dump the context class
        // @implementation FooContext
        // - (id)initWithOwner:(Objective C*)owner;
        // ...
        //
        _source.print(_indent);
        _source.print("@implementation ");
        _source.print(fsmClassName);
        _source.println("");

        // Convert SMC scope syntax to Objective-C syntax.
        if (fqStateName.indexOf("::") >= 0)
        {
            fqStateName = convertScope(fqStateName);
        }

        // Dump the initWithOwner method
        // - (id)initWithOwner:(Foo*)owner;
        // {
        //     self = [super initWithState: [Map Start];
        //     if (!self) {
        //         return nil;
        //     }
        //     _owner = owner;
        //     return self;
        // }
        _source.print(_indent);
        _source.print("- (id)initWithOwner:(");
        _source.print(context);
        _source.print("*)");
        _source.println("owner;");
        _source.print(_indent);
        _source.println("{");
        _source.print(_indent);
        _source.print("    ");
        _source.print("self = [super initWithState:");
        _source.print(fqStateName);
        _source.println("];");
        _source.print(_indent);
        _source.print("    ");
        _source.println("if (!self)");
        _source.print(_indent);
        _source.println("{");
        _source.print(_indent);
        _source.print("        ");
        _source.println("return nil;");
        _source.print(_indent);
        _source.println("    }");
        _source.print(_indent);
        _source.print("    ");
        _source.println("_owner = owner;");

        _source.print(_indent);
        _source.print("    ");
        _source.println("return self;");
        _source.print(_indent);
        _source.println("}");

        // Dump the initWithOwner state method
        // - (id)initWithOwner:(Foo*)owner state:(SMCState*)aState;
        // {
        //     self = [super initWithState: aState;
        //     if (!self) {
        //         return nil;
        //     }
        //     _owner = owner;
        //     return self;
        // }
        _source.print(_indent);
        _source.print("- (id)initWithOwner:(");
        _source.print(context);
        _source.print("*)");
        _source.println("owner state:(SMCState*)aState;");
        _source.print(_indent);
        _source.println("{");
        _source.print(_indent);
        _source.print("    ");
        _source.println("self = [super initWithState: aState];");
        _source.print(_indent);
        _source.print("    ");
        _source.println("if (!self)");
        _source.print(_indent);
        _source.println("{");
        _source.print(_indent);
        _source.print("        ");
        _source.println("return nil;");
        _source.print(_indent);
        _source.println("    }");
        _source.print(_indent);
        _source.print("    ");
        _source.println("_owner = owner;");

        _source.print(_indent);
        _source.print("    ");
        _source.println("return self;");
        _source.print(_indent);
        _source.println("}");
		
		// add dealloc
		_source.print(_indent);
		_source.println("- (void)dealloc");
		_source.print(_indent);
		_source.println("{");
		
        for (mapIt = fsm.getMaps().iterator(), index = 0;
             mapIt.hasNext() == true;
			 )
        {
            map = mapIt.next();
            mapName = map.getName();

			_source.print(_indent);
			_source.print("    [");
			_source.print(mapName);
			_source.println(" cleanupStates];");
		}
		
		_source.print(_indent);
        _source.println("    [super dealloc];");
		_source.print(_indent);
		_source.println("}");

        // Output the state method
        // - (FooState*)state;
        // {
        //     return (FooState*)_state;
        // }
        _source.print(_indent);
        _source.print("- (" );
        _source.print(context);
        _source.println("State*)state;");
        _source.print(_indent);
        _source.println("{");
        _source.print(_indent);
        _source.print("    ");
        _source.print("return (");
        _source.print(context);
        _source.println("State*)_state;");
        _source.print(_indent);
        _source.println("}");

        // Output the owner method.
        // - (Foo*)owner;
        // {
        //     return _owner;
        // }
        _source.print(_indent);
        _source.print("- (");
        _source.print(context);
        _source.println("*)owner;");
        _source.print(_indent);
        _source.println("{");
        _source.print(_indent);
        _source.print("    ");
        _source.println("return _owner;");
        _source.print(_indent);
        _source.println("}");

        // Output the enterStartState method.
        // - (void)enterStartState;
        // {
        //     [[self state] Entry:self];
        // }
        _source.print(_indent);
        _source.println("- (void)enterStartState;");
        _source.print(_indent);
        _source.println("{");
        _source.print(_indent);
        _source.println("    [[self state] Entry:self];");
        _source.print(_indent);
        _source.println("}");

        // Generate a method for every transition in every map
        // *except* the default transition.
        for (SmcTransition trans: transList)
        {
            if (trans.getName().equals("Default") == false)
            {
                _source.println();
                _source.print(_indent);
                _source.print("- (void)");
                _source.print(trans.getName());

                params = trans.getParameters();
                for (pit = params.iterator(),
                       separator = ":";
                     pit.hasNext() == true;
                     separator = " :")
                {
                    _source.print(separator);
                    (pit.next()).accept(this);
                }
                _source.println(";");

                _source.print(_indent);
                _source.println("{");

                // If -g was specified, then set the transition
                // name so it can be printed out.
                if (_debugLevel >= DEBUG_LEVEL_0)
                {
                    _source.print(_indent);
                    _source.print("    [self setTransition:@\"");
                    _source.print(trans.getName());
                    _source.println("\"];");
                }

                _source.print(_indent);
                _source.print("    [[self state] ");
                _source.print(trans.getName());
                _source.print(":self");
                for (pit = params.iterator();
                     pit.hasNext() == true;
                    )
                {
                    _source.print(" :");
                    _source.print((pit.next()).getName());
                }
                _source.println("];");

                if (_debugLevel >= DEBUG_LEVEL_0)
                {
                    _source.print(_indent);
                    _source.println(
                        "    [self setTransition:nil];");
                }

                _source.print(_indent);
                _source.println("}");
            }
        }

        // End the class implementation
        _source.print(_indent);
        _source.println("@end");

        _source.println();
        _source.println("/*");
        _source.println(" * Local variables:");
        _source.println(" *  buffer-read-only: t");
        _source.println(" * End:");
        _source.println(" */");

        return;
    } // end of visit(SmcFSM)

    /**
     * Emits Objective C code for the FSM map.
     * @param map emit Objective C code for this map.
     */
    public void visit(SmcMap map)
    {
        // Print out the default state class
        _source.println();
        _source.print(_indent);
        _source.print("@implementation ");
        _source.print(map.getName());
        _source.println("_Default");

        // Declare the user-defined default transitions first.
        if (map.hasDefaultState() == true)
        {
            SmcState defaultState = map.getDefaultState();

            for (SmcTransition transition:
                     defaultState.getTransitions())
            {
                transition.accept(this);
            }
        }

        _source.println("@end");

        // Have each state now generate its code.
        for (SmcState state: map.getStates())
        {
            state.accept(this);
        }

        return;
    } // end of visit(SmcMap)

    /**
     * Emits Objective C code for this FSM state.
     * @param state emits Objective C code for this state.
     */
    public void visit(SmcState state)
    {
        SmcMap map = state.getMap();
        String context = map.getFSM().getContext();
        String fsmClassName = map.getFSM().getFsmClassName();
        String mapName = map.getName();
        String className = state.getClassName();
        String indent2;
        List<SmcAction> actions;

        _source.print(_indent);
        _source.print("@implementation ");
        _source.print(mapName);
        _source.print("_");
        _source.println(className);

        // Add the Entry() and Exit() methods if this state
        // defines them.
        actions = state.getEntryActions();
        if (actions != null && actions.size() > 0)
        {
            _source.print(_indent);
            _source.print("- (void)Entry:(");
            _source.print(fsmClassName);
            _source.println("*)context;");
            _source.println();
            _source.println("{");

            // Declare the "ctxt" local variable.
            _source.print(_indent);
            _source.print("    ");
            _source.print(context);
            _source.println(" *ctxt = [context owner];");
            _source.println();

            // Generate the actions associated with this code.
            indent2 = _indent;
            _indent = _indent + "    ";
            for (SmcAction action: actions)
            {
                action.accept(this);
            }
            _indent = indent2;

            // End the Entry() method with a return.
            _source.print(_indent);
            _source.println("}");
        }

        actions = state.getExitActions();
        if (actions != null && actions.size() > 0)
        {
            _source.print(_indent);
            _source.print("- (void)Exit:(");
            _source.print(fsmClassName);
            _source.println("*)context;");
            _source.println();
            _source.println("{");

            // Declare the "ctxt" local variable.
            _source.print(_indent);
            _source.print("    ");
            _source.print(context);
            _source.println(" *ctxt = [context owner];");
            _source.println();

            // Generate the actions associated with this code.
            indent2 = _indent;
            _indent = _indent + "    ";
            for (SmcAction action: actions)
            {
                action.accept(this);
            }
            _indent = indent2;

            _source.print(_indent);
            _source.println("}");
        }

        // Have the transitions generate their code.
        for (SmcTransition transition: state.getTransitions())
        {
            transition.accept(this);
        }

        _source.print(_indent);
        _source.println("@end");
        _source.println();

        return;
    } // end of visit(SmcState)

    /**
     * Emits Objective C code for this FSM state transition.
     * @param transition emits Objective C code for this state
     * transition.
     */
    public void visit(SmcTransition transition)
    {
        SmcState state = transition.getState();
        SmcMap map = state.getMap();
        String context = map.getFSM().getContext();
        String fsmClassName = map.getFSM().getFsmClassName();
        String mapName = map.getName();
        String stateName = state.getClassName();
        String transName = transition.getName();
        boolean nullCondition = false;
        List<SmcGuard> guards = transition.getGuards();
        Iterator<SmcGuard> git;
        SmcGuard guard;
        String fqStateName;

        // Qualify the state name as well.
        if (stateName.indexOf("::") < 0)
        {
            fqStateName = "[" + mapName + " " + stateName + "]";
        }
        else
        {
            fqStateName = stateName;
        }

        _source.println();
        _source.print(_indent);
        _source.print("- (void)");
        _source.print(transName);
        _source.print(":(");
        _source.print(fsmClassName);
        _source.print("*)context");

        // Add user-defined parameters.
        for (SmcParameter param: transition.getParameters())
        {
            _source.print(" :");
            param.accept(this);
        }

        _source.println(";");
        _source.print(_indent);
        _source.println("{");

        // All transitions have a "ctxt" local variable.
        // 8/14/2003:
        // Do this only if there are any transition actions or
        // guard conditions which reference it.
        if (transition.hasCtxtReference() == true)
        {
            _source.print(_indent);
            _source.print("    ");
            _source.print(context);
            _source.println(" *ctxt = [context owner];");
        }

        // Print the transition to the verbose log.
        if (_debugLevel >= DEBUG_LEVEL_0)
        {
            _source.print(_indent);
            _source.println("    if ( [context debugFlag] )");
            _source.print(_indent);
            _source.println("    {");
            _source.print(_indent);
            _source.print(
                    "        TRACE(@\"LEAVING STATE   : ");
            _source.print(mapName);
            _source.print("::");
            _source.print(stateName);
            _source.println("\\n\\r\");");
            _source.print(_indent);
            _source.println("    }");
        }


        // Loop through the guards and print each one.
        for (git = guards.iterator(),
                     _guardIndex = 0,
                     _guardCount = guards.size();
             git.hasNext() == true;
             ++_guardIndex)
        {
            guard = git.next();

            // Count up the number of guards with no condition.
            if (guard.getCondition().length() == 0)
            {
                nullCondition = true;
            }

            guard.accept(this);
        }

        // If all guards have a condition, then create a final
        // "else" clause which passes control to the default
        // transition.
        if (_guardIndex > 0 && nullCondition == false)
        {
            // If there is only one transition definition, then
            // close off the guard.
            if (_guardCount == 1)
            {
                _source.print(_indent);
                _source.println("    }");
            }

            // else
            // {
            //     [super commitCrime:context];
            // }
            _source.print(_indent);
            _source.println("    else");
            _source.print(_indent);
            _source.println("    {");
            _source.print(_indent);
            _source.print("         [super ");
            _source.print(transName);
            _source.print(":context");

            // Output user-defined parameters.
            for (SmcParameter param: transition.getParameters())
            {
                _source.print(" :");
                _source.print(param.getName());
            }
            _source.println("];");
            _source.print(_indent);
            _source.println("    }");
        }
        else if (_guardCount > 1)
        {
            _source.println();
        }

        _source.print(_indent);
        _source.println("}");

        return;
    } // end of visit(SmcTransition)

    /**
     * Emits Objective C code for this FSM transition guard.
     * @param guard emits Objective C code for this transition
     * guard.
     */
    public void visit(SmcGuard guard)
    {
        SmcTransition transition = guard.getTransition();
        SmcState state = transition.getState();
        SmcMap map = state.getMap();
        String context = map.getFSM().getContext();
        String mapName = map.getName();
        String stateName = state.getClassName();
        String transName = transition.getName();
        TransType transType = guard.getTransType();
        boolean loopbackFlag = false;
        String indent2;
        String indent3;
        String indent4 = "";
        String endStateName = guard.getEndState();
        String fqEndStateName = "";
        String pushStateName = guard.getPushState();
        String condition = guard.getCondition();
        List<SmcAction> actions = guard.getActions();

        // If this guard's end state is not of the form
        // "map::state", then prepend the map name to the state
        // name.
        // DON'T DO THIS IF THIS IS A POP TRANSITION!
        // The "state" is actually a transition name.
        if (transType != TransType.TRANS_POP &&
            endStateName.length () > 0 &&
            endStateName.equals(SmcElement.NIL_STATE) == false &&
            endStateName.indexOf("::") < 0)
        {
            endStateName = mapName + "::" + endStateName;
        }

        // Convert the SMC scope syntex to the Objective-C
        // syntax.
        if (endStateName.indexOf("::") >= 0)
        {
            endStateName = convertScope(endStateName);
        }

        // Qualify the state name as well.
        if (stateName.indexOf("::") >= 0)
        {
            stateName = convertScope(stateName);
        }

        loopbackFlag = isLoopback(transType, endStateName);

        // v. 2.0.2: If the push state is not fully-qualified,
        // then prepend the current map's name and make if
        // fully-qualified.
        if (pushStateName != null &&
            pushStateName.length() > 0 &&
            pushStateName.indexOf("::") < 0)
        {
            pushStateName =
                "[" + mapName + " " + pushStateName + "]";
        }

        if (pushStateName.indexOf("::") >= 0)
        {
            pushStateName = convertScope(pushStateName);
        }

        // The guard code generation is a bit tricky. The first
        // question is how many guards are there? If there are
        // more than one, then we will need to generate the
        // proper "if-then-else" code.
        if (_guardCount > 1)
        {
            indent2 = _indent + "        ";

            // More than one guard. Is this the first guard?
            if (_guardIndex == 0 && condition.length() > 0)
            {
                // Yes, this is the first. This means an
                // "if" should be used for this condition.
                _source.print(_indent);
                _source.print("    if (");
                _source.print(condition);
                _source.println(")");
                _source.print(_indent);
                _source.println("    {");
            }
            else if (condition.length() > 0)
            {
                // No, this is not the first transition but it
                // does have a condition. Use an "else if" for
                // the condition.
                _source.println();
                _source.print(_indent);
                _source.print("    else if (");
                _source.print(condition);
                _source.println(")");
                _source.println(_indent);
                _source.println("    {");
            }
            else
            {
                // This is not the first transition and it has
                // no condition.
                _source.println();
                _source.print(_indent);
                _source.println("    else");
                _source.print(_indent);
                _source.println("    {");
            }
        }
        else
        {
            // There is only one guard. Does this guard have a
            // condition.
            if (condition.length() == 0)
            {
                // Actually, this is a plain, old, vaniila
                // transition.
                indent2 = _indent + "    ";
            }
            else
            {
                // Yes, there is a condition.
                _source.print(_indent);
                _source.print("    if (");
                _source.print(condition);
                _source.println(")");
                _source.print(_indent);
                _source.println("    {");
                indent2 = _indent + "        ";
            }
        }

        // Now that the necessary conditions are in place, it's
        // time to dump out the transitions actions. First, do
        // the proper handling of the state change. If this
        // transition has no actions, then set the end state
        // immediately. Otherwise, unset the current state so
        // that if an action tries to issue a transition, it will
        // fail.
        if (actions.size() == 0 && endStateName.length() > 0)
        {
            fqEndStateName = endStateName;
        }
        else if (actions.size() > 0)
        {
            // Save away the current state if this is a loopback
            // transition. Storing current state allows the
            // current to be cleared before any actions are
            // executed. Remember: actions are not allowed to
            // issue transitions and clearing the current state
            // prevents them from doing so.
            if (loopbackFlag == true)
            {
                fqEndStateName = "EndStateName";

                _source.print(indent2);
                _source.print(context);
                _source.print("State* ");
                _source.print(fqEndStateName);
                _source.println(" = [context state];");
                _source.println();
            }
            else
            {
                fqEndStateName = endStateName;
            }
        }

        // Before doing anything else, perform the current
        // state's exit actions.
        // v. 1.0, beta 3: Not any more. The exit actions are
        // executed only if 1) this is a standard, non-loopback
        // transition or a pop transition.
        if (transType == TransType.TRANS_POP ||
            loopbackFlag == false)
        {
            if (_debugLevel >= DEBUG_LEVEL_1)
            {
                _source.print(indent2);
                _source.println("if ( [context debugFlag] )");
                _source.print(indent2);
                _source.print("{");
                _source.print(indent2);
                _source.print("    TRACE(@\"BEFORE EXIT     : ");
                _source.print(stateName);
                _source.println("\\n\\r\");");
                _source.print(indent2);
                _source.print("}");
            }

            _source.print(indent2);
            _source.println("[[context state] Exit:context];");

            if (_debugLevel >= DEBUG_LEVEL_1)
            {
                _source.print(indent2);
                _source.println("if ( [context debugFlag] )");
                _source.print(indent2);
                _source.print("{");
                _source.print(indent2);
                _source.print("    TRACE(@\"AFTER EXIT      : ");
                _source.print(stateName);
                _source.println("\\n\\r\");");
                _source.print(indent2);
                _source.print("}");
            }
        }

        if (_debugLevel >= DEBUG_LEVEL_0)
        {
            Iterator<SmcParameter> pit;
            String sep;

            _source.print(indent2);
            _source.println("if ( [context debugFlag] )");
            _source.print(indent2);
            _source.println("{");
            _source.print(indent2);
            _source.print("    TRACE(@\"ENTER TRANSITION: ");
            _source.print(mapName);
            _source.print(" ");
            _source.print(transName);
            _source.print("(");

            for (pit = transition.getParameters().iterator(),
                 sep = "";
                 pit.hasNext() == true;
                 sep = " ")
            {
                _source.print(sep);
                (pit.next()).accept(this);
            }

            _source.println(")\\n\\r\");");

            _source.print(indent2);
            _source.println("}");
        }

        // Dump out this transition's actions.
        if (actions.isEmpty() == true)
        {
            if (condition.length() > 0)
            {
                _source.print(indent2);
                _source.println("// No actions.");
            }

            indent3 = indent2;
        }
        else
        {
            // Now that we are in the transition, clear the
            // current state.
            _source.print(indent2);
            _source.println("[context clearState];");

            indent3 = indent2;
            indent4 = _indent;
            _indent = indent3;

            for (SmcAction action: actions)
            {
                action.accept(this);
            }

            _indent = indent4;
        }

        if (_debugLevel >= DEBUG_LEVEL_0)
        {
            Iterator<SmcParameter> pit;
            String sep;

            _source.print(indent3);
            _source.println("if ( [context debugFlag] )");
            _source.print(indent3);
            _source.println("{");
            _source.print(indent3);
            _source.print("    TRACE(@\"EXIT TRANSITION : ");
            _source.print(mapName);
            _source.print(" ");
            _source.print(transName);
            _source.print("(");

            for (pit = transition.getParameters().iterator(),
                 sep = "";
                 pit.hasNext() == true;
                 sep = " ")
            {
                _source.print(sep);
                (pit.next()).accept(this);
            }

            _source.println(")\\n\\r\");");

            _source.print(indent3);
            _source.println("}");
        }

        // Print the setState() call, if necessary. Do NOT
        // generate the set state if:
        // 1. The transition has no actions AND is a loopback OR
        // 2. This is a push or pop transition.
        //
        // v. 2.0.2: The following code must be generated twice -
        // once for the try body and again for the catch body.
        // Unlike Java, C++ does not have a finally clause.
        if (transType == TransType.TRANS_SET &&
            (actions.isEmpty() == false ||
             loopbackFlag == false))
        {
            _source.print(indent3);
            _source.print("[context setState:");
            _source.print(fqEndStateName);
            _source.println("];");
        }
        else if (transType == TransType.TRANS_PUSH)
        {
            // Set the end state so that it can be pushed
            // onto the state stack. But only do so if a clear
            // state was done.
            if (loopbackFlag == false || actions.size() > 0)
            {
                _source.print(indent3);
                _source.print("[context setState:");
                _source.print(fqEndStateName);
                _source.println("];");
            }

            // Before doing the push, execute the end state's
            // entry actions (if any) if this is not a loopback.
            if (loopbackFlag == false)
            {
                if (_debugLevel >= DEBUG_LEVEL_1)
                {
                    _source.print(indent3);
                    _source.println(
                        "if ( [context debugFlag] )");
                    _source.print(indent3);
                    _source.print("{");
                    _source.print(indent3);
                    _source.print(
                        "    TRACE(@\"BEFORE ENTRY    : ");
                    _source.print(fqEndStateName);
                    _source.println("\\n\\r\");");
                    _source.print(indent3);
                    _source.print("}");
                }

                _source.println();
                _source.print(indent3);
                _source.println(
                    "[[context state] Entry:context];");

                if (_debugLevel >= DEBUG_LEVEL_1)
                {
                    _source.print(indent3);
                    _source.println(
                        "if ( [context debugFlag] )");
                    _source.print(indent3);
                    _source.print("{");
                    _source.print(indent3);
                    _source.print(
                        "    TRACE(@\"AFTER ENTRY     : ");
                    _source.print(fqEndStateName);
                    _source.println("\\n\\r\");");
                    _source.print(indent3);
                    _source.print("}");
                }
            }

            _source.print(indent3);
            _source.print("[context pushState:");
            _source.print(pushStateName);
            _source.println("];");
        }
        else if (transType == TransType.TRANS_POP)
        {
            _source.print(indent3);
            _source.println("[context popState];");
        }

        // Perform the new state's entry actions.
        // v. 1.0, beta 3: Not any more. The entry actions are
        // executed only if 1) this is a standard, non-loopback
        // transition or a push transition.
        if ((transType == TransType.TRANS_SET &&
             loopbackFlag == false) ||
             transType == TransType.TRANS_PUSH)
        {
            if (_debugLevel >= DEBUG_LEVEL_1)
            {
                _source.print(indent2);
                _source.println("if ( [context debugFlag] )");
                _source.print(indent2);
                _source.print("{");
                _source.print(indent2);
                _source.print("    TRACE(@\"BEFORE ENTRY    : ");
                _source.print(fqEndStateName);
                _source.println("\\n\\r\");");
                _source.print(indent2);
                _source.print("}");
            }

            _source.print(indent2);
            _source.println("[[context state] Entry:context];");

            if (_debugLevel >= DEBUG_LEVEL_1)
            {
                _source.print(indent2);
                _source.println("if ( [context debugFlag] )");
                _source.print(indent2);
                _source.print("{");
                _source.print(indent2);
                _source.print("    TRACE(@\"AFTER ENTRY     : ");
                _source.print(fqEndStateName);
                _source.println("\\n\\r\");");
                _source.print(indent2);
                _source.print("}");
            }
        }

        // If there is a transition associated with the pop, then
        // issue that transition here.
        if (transType == TransType.TRANS_POP &&
            endStateName.equals(SmcElement.NIL_STATE) == false &&
            endStateName.length() > 0)
        {
            String popArgs = guard.getPopArgs();
            int popLength = popArgs.length();

            _source.print(indent2);
            _source.print("[context ");
            _source.print(endStateName);

            // Output any and all pop arguments.
            if (popLength > 0)
            {
                int cur;
                int comma;

                for (cur = 0, comma = popArgs.indexOf(',');
                     comma >= 0;
                     cur = (comma + 1),
                         comma = popArgs.indexOf(',', cur))
                {
                    _source.print(':');
                    _source.print(popArgs.substring(cur, comma));
                }

                if (cur < popLength)
                {
                    _source.print(':');
                    _source.print(popArgs.substring(cur));
                }
            }
            _source.println("];");
        }

        // If this is a guarded transition, it will be necessary
        // to close off the "if" body. DON'T PRINT A NEW LINE!
        // Why? Because an "else" or "else if" may follow and we
        // won't know until we go back to the transition source
        // generator whether all clauses have been done.
        if (_guardCount > 1)
        {
            _source.print(_indent);
            _source.print("    }");
        }

        return;
    } // end of visit(SmcGuard)

    /**
     * Emits Objective C code for this FSM action.
     * @param action emits Objective C code for this action.
     */
    public void visit(SmcAction action)
    {
        String name = action.getName();
        String sep = ":";

        // Need to distinguish between FSMContext actions and
        // application class actions. If the action is
        // "emptyStateStack", then pass it to the context.
        // Otherwise, let the application class handle it.
        _source.print(_indent);
        if (action.isEmptyStateStack() == true)
        {
            _source.println("[context emptyStateStack];");
        }
        else
        {
            _source.print("[ctxt ");
	        _source.print(name);
	
	        for (String arg: action.getArguments())
	        {
	            if (arg.trim().length() > 0)
	            {
	                _source.print(sep);
	                _source.print(arg);
	            }
	        }
	
	        _source.println("];");
        }
        return;
    } // end of visit(SmcAction)

    /**
     * Emits Objective C code for this transition parameter.
     * @param parameter emits Objective C code for this
     * transition parameter.
     */
    public void visit(SmcParameter parameter)
    {
        _source.print("(");
        _source.print(parameter.getType());
        _source.print(")");
        _source.print(parameter.getName());

        return;
    } // end of visit(SmcParamter)

    //
    // end of SmcVisitor Abstract Method Impelementation.
    //-----------------------------------------------------------

    // Converts the SMC scope syntax to Objective-C syntax.
    private String convertScope(String s)
    {
        int index = s.indexOf("::");

        return ("[" +
                s.substring(0, index) +
                " " +
                s.substring((index + 2)) +
                "]");
    } // end of convertScope(String)

//---------------------------------------------------------------
// Member data
//
} // end of class SmcObjCGenerator

//
// CHANGE LOG
// $Log: SmcObjCGenerator.java,v $
// Revision 1.11  2011/11/20 14:58:33  cwrapp
// Check in for SMC v. 6.1.0
//
// Revision 1.10  2010/02/15 18:05:43  fperrad
// fix 2950619 : make distinction between source filename (*.sm) and target filename.
//
// Revision 1.9  2009/12/17 19:51:43  cwrapp
// Testing complete.
//
// Revision 1.8  2009/11/25 22:30:19  cwrapp
// Fixed problem between %fsmclass and sm file names.
//
// Revision 1.7  2009/11/24 20:42:39  cwrapp
// v. 6.0.1 update
//
// Revision 1.6  2009/10/06 15:31:59  kgreg99
// 1. Started implementation of feature request #2718920.
//     1.1 Added method boolean isStatic() to SmcAction class. It returns false now, but is handled in following language generators: C#, C++, java, php, VB. Instance identificator is not added in case it is set to true.
// 2. Resolved confusion in "emtyStateStack" keyword handling. This keyword was not handled in the same way in all the generators. I added method boolean isEmptyStateStack() to SmcAction class. This method is used instead of different string comparisons here and there. Also the generated method name is fixed, not to depend on name supplied in the input sm file.
//
// Revision 1.5  2009/09/12 21:44:49  kgreg99
// Implemented feature req. #2718941 - user defined generated class name.
// A new statement was added to the syntax: %fsmclass class_name
// It is optional. If not used, generated class is called as before "XxxContext" where Xxx is context class name as entered via %class statement.
// If used, generated class is called asrequested.
// Following language generators are touched:
// c, c++, java, c#, objc, lua, groovy, scala, tcl, VB
// This feature is not tested yet !
// Maybe it will be necessary to modify also the output file name.
//
// Revision 1.4  2009/09/05 15:39:20  cwrapp
// Checking in fixes for 1944542, 1983929, 2731415, 2803547 and feature 2797126.
//
// Revision 1.3  2009/04/10 14:02:48  cwrapp
// Set initial state via initializer.
//
// Revision 1.2  2009/03/27 09:41:47  cwrapp
// Added F. Perrad changes back in.
//
// Revision 1.1  2009/03/01 18:20:42  cwrapp
// Preliminary v. 6.0.0 commit.
//
//
