<#if transition.guards.count > 1>

	<#if transition.guards.first == guard>
		if (${guard.condition})
	<#elseif guard.condition.length > 0>
		else if (${guard.condition}
	<#else>
		else
	</#if>
		{

           
<#elseif guard.condition.length == 0>
        
<#else>
		if (${guard.condition})
		{
</#if>

        // Now that the necessary conditions are in place, it's
        // time to dump out the guard.transition's actions. First, do
        // the proper handling of the guard.transition.state change. If this
        // guard.transition has no actions, then set the end guard.transition.state
        // immediately. Otherwise, unset the current guard.transition.state so
        // that if an action tries to issue a guard.transition, it will
        // fail.

<#if (hasActions == false || !{guard.isLoopback}>
            fqEndStateName = ${guard.endStateScoped};
<#else>
			${context}State endState = context.getState();
</#if>
        // 

        // Dump out the exit actions - but only for the first
        // guard.
        // v. 1.0, beta 3: Not any more. The exit actions are
        // executed only if 1) this is a standard, non-loopback
        // guard.transition or a pop guard.transition.
        
<#if guard.transType = TransType.TRANS_POP || (!guard.isLoopback>
            if (log.isTraceEnabled())
            {
                    log.trace("BEFORE EXIT     : ${map.name}.${state.name}.Exit(context) [" + context.getName() + "]");
            }
            (context.getState()).Exit(context);
 
            if (log.isTraceEnabled())
            {
                    log.trace("AFTER EXIT     : ${map.name}.${state.name}.Exit(context) [" + context.getName() + "]");
            }
</#if>

        // Output guard.transition to debug stream.
<#if debugLevel > 0>
             if (log.isTraceEnabled())
             {
             	log.trace("ENTER transition: ${map.name}.${state.name}.${transition.name}(
	<#list transition.parameters as param>
             		${param.type} ${param.name}
		<#if transition.parameters.last != param>
             			,
		</#if>
	</#list>
				[" + ${context.name} + "]");
             }
           
</#if>

        // Dump out this guard.transition's actions.
<#if guard.actions.count == 0>
	<#if guard.condition>
		// No actions
	</#if>
<#else>
	context.clearState();
			
				
	<#if !noCatchFlag>
				try {
	</#if>			
	
	<#list guard.actions as action>
		<#if action.isEmptyStateStack>
			context.emptyStateStack();
		<#else>
			<#if action.isStatic>
				ctxt.${action.name}(
			<#else>
				ctxt.${action.name}(
			</#if>
			<#list action.arguments as arg>
				${arg}
				<#if action.arguments.last != arg>
					,
				</#if>
				);
			
		</#if>
	
	<#if !noCatchFlag>
				 } finally {
	</#if>			
	
	<#if debugLevel > 0>
	
				if (log.isTraceEnabled())
				 {
					log.trace("EXIT transition: ${map.name}.${state.name}.${transition.name}(
		<#list transition.parameters as param>
						${param.type} ${param.name}
			<#if transition.parameters.last != param>
							,
			</#if>
		</#list>
					[" + ${context.name} + "]");
				 }        
	</#if>
	
</#if>
	
			// Print the setState() call, if necessary. Do NOT
			// generate the set guard.transition.state it:
			// 1. The guard.transition has no actions AND is a loopback OR
			// 2. This is a push or pop guard.transition.
			
<#if transType == TransType.TRANS_SET && (hasActions || guard.isLoopback) > 
				context.setState(${guard.endStateScoped});
<#elseif transType = TransType.TRANS_PUSH>				

	<#if guard.isLoopback || guard.hasActions>
		context.setState(${guard.endStateScoped});
	</#if>
	<#if !guard.isLoopback>
		(context.getState()).Entry(context);
	</#if>
	context.pushState(guard.pushStateScoped);
<#elseif transType == TransType.TRANS_POP>
	context.popState();
</#if>
	
				
	
			// Perform the new guard.transition.state's enty actions.
			// v. 1.0, beta 3: Not any more. The entry actions are
			// executed only if 1) this is a standard, non-loopback
			// guard.transition or a push guard.transition.
<#if guard.transType == TransType.TRANS_SET || (!guard.isLoopback) || transType == TransType.TRANS_PUSH>
	
				if (log.isTraceEnabled())
				{
					log.trace("BEFORE ENTRY     : ${map.name}.${state.name}.Entry(context)[" + context.getName() + "]");
				}
				
				(context.getState()).Entry(context);
	
				if (log.isTraceEnabled())
				{
					log.trace("AFTER ENTRY     : ${map.name}.${state.name}.Entry(context)[" + context.getName() + "]");
				}
				
			}
</#if>	
<#if !noCatchFlag>
	}
</#if>

<#if guard.transType == TransType.TRANS_POP &&
            guard.endState != SmcElement.NIL_STATE &&
            guard.endState.length() > 0>
        // If there is a transition associated with the pop, then
        // issue that transition here.
        context.${guard.endStateScoped}(${guard.popArgs});
</#if>
<#if transition.guards.count > 1>
}
</#if>