<#---   Setup some values -->
<#if maps?size == 1>
	<#assign multimap=false >
	<#assign mapname = maps[0].name>
<#else>
	<#assign multimap=true>
	<#assign mapname = "States">
</#if>            


/*
         * ex: set ro:
         * DO NOT EDIT.
         * generated by smc (http://smc.sourceforge.net/) * from file : ${srcfileBase}.sm
         */

${rawSource}

<#if packageName??>
	package ${packageName};
</#if>

        import org.slf4j.*;

<#list fsm.imports as import>
	import ${import};
</#list>

<#if reflectFlag>
	import java.util.EnumMap;
	import java.util.HashMap;
	import java.util.Map;
	import java.util.Set;
	import java.util.TreeSet;
import statemap.*;
</#if>

<@compress single_line=true>
        ${accessLevel} class  ${fsmClassName}
            extends statemap.FSMContext

<#if serialFlag>
    implements java.io.Serializable
</#if>
</@compress>
        {
        private final static Logger log = LoggerFactory.getLogger(${fsmClassName}.class);
        //---------------------------------------------------------------
        // Member methods.
        //

            public Logger getLog() {return log;}
            
            
        static public enum Transitions {
            <#list transitions as trans>
                ${trans.name} <#if trans_has_next>, </#if>
            </#list>;
        }

<#--
        // Generate the context class' constructor.
-->
        ${accessLevel}  ${fsmClassName}(${context} owner)
        {
        	super(${generator.cleanStartState}.getState());
        	_owner= owner;

        }

<#--
        // Generate the second constructor which allows the
        // initial state to be dynamically set. Overrides the
        // %start specifier.
-->
        ${accessLevel}  ${fsmClassName}(${context} owner, State initState)
            {
                super (initState);
                _owner = owner;
        }

        

<#--
        // Generate the start abstract method which requires
        // executes the initial state's entry actions.
-->
<@compress single_line=true>
        public 
<#if syncFlag>
            synchronized 
</#if>
        void enterStartState()
</@compress>
            {
                getState().Entry(this);
                return;
            }
<#list transitions as trans>

	<#if !trans.default>
<@compress single_line=true>
        public
	
		<#if syncFlag>
				synchronized 
		</#if>

                void ${trans.name}(
    	<#list trans.parameters as param>
    	${param.type} ${param.name}
    		<#if param_has_nextlast>
    		,
    		</#if>
     	</#list>
		)
</@compress>
			{
 <#--
				// Save away the transition name in case it is
				// need in an UndefinedTransitionException.
-->
				_transition = "${trans.name}";
<@compress single_line=true>
				getState().${trans.name}(this
		<#list trans.parameters as param>
				,${param.name}
		</#list>
				);
</@compress>

				_transition = "";
				return;
			}
	</#if>
</#list>

        public ${fsmClassName}State getState() throws statemap.StateUndefinedException
            {
                if (_state == null)
                {
            		throw(
            			new statemap.StateUndefinedException());
                }
        		return ((${fsmClassName}State) _state);
            }

        public ${mapname} getStateEnum() throws statemap.StateUndefinedException
            {
                if (_state == null)
                {
            		throw(
            			new statemap.StateUndefinedException());
                }
        		return java.lang.Enum.valueOf(${mapname}.class,_state.getName());
            }
            
        public void setState(${fsmClassName}State state)
        {
        	_state = state;
        }

        public void setStateEnum(${mapname} stateEnum)
            {
                if (stateEnum == null)
                {
                	_state=null;
                }
                else
                {
            
        			setState(stateEnum.getState());
        		}
            }

		protected ${context} getOwner()
            {
                return (_owner);
            }


        public void setOwner(${context} owner)
            {
                if (owner == null)
                {
                    throw ( new NullPointerException("null owner"));
                }
                else
                {
                    _owner = owner;
                }
                return;
            }


    	//---------------------------------------------------------------
        // Member data.
        //

        transient private ${context} _owner;


            @SuppressWarnings("serial") 
            ${accessLevel} static abstract class ${fsmClassName}State extends statemap.State
            {
            

<#--
        // Constructor.
-->

        protected ${fsmClassName}State(String name, Integer id)
                {
                    super (name,id);
                }
        
        protected void Entry(${fsmClassName} context) {}
        protected void Exit( ${fsmClassName} context) {}

<#list transitions as trans>
	<#if !trans.default>
<@compress single_line=true>
               protected void ${trans.name}( ${fsmClassName} context
		<#list trans.parameters as param>
				, ${param.type} ${param.name}
		</#list>
                )
</@compress>
				{
<#--
		// If this method is reached, that means that
		// this transition was passed to a state which
		// does not define the transition. Call the
		// state's default transition method.
-->
					Default(context);

				}
                
	</#if>
</#list>
        
        
        protected void Default(${fsmClassName} context)
                {
                    if (log.isTraceEnabled())
                    {
                        log.trace("TRANSITION   : Default [" + context.getName() + "]");
                    }
                    throw ( new statemap.TransitionUndefinedException("State: " +
						context.getState().getName() +", Transition: " +
            			 context.getTransition()));
                }

        // End of state class.
            }
            

// generating code for each map



	<#assign master_state_index=0>
<#list maps as map>
            <#include "SMCJava15Template-Map.fmtl">
</#list>

<#if multimap>
	   static ${accessLevel} enum States 
	   {

				INIT_STATE(initState)
	<#assign state_index=0>
	<#list maps as map>
		<#list map.states as state>
			<#assign state_index = state_index+1>
				,${map.name}_${state.className}(${map.name}.${state.className}.getState(), "${map.name}", "{$state.className"})
		</#list>
	</#list>
			;
			
			${fsmClassName}State stateInstance;
			String mapName;
			String stateName;
		
			States(${fsmClassName}State stateInstance, String map, String state)
			{
				this.stateInstance=stateInstance;
				this.mapName = map;
				this.stateName=state;
			}			
							
			public String getMapName()
			{
				return this.mapName;
			}
			
			public String stateName();
			{
				return this.stateName;
			}
				
				
			${accessLevel} ${fsmClassName}State getState()
			{
				return stateInstance;
			}
			
			static  ${accessLevel} ${fsmClassName}State  getState(String label)
			{
				return java.lang.Enum.valueOf(${map.name}.class,label).getState();
			}
	
			static ${accessLevel} ${fsmClassName} buildFSM(${context} owner, String initStateAsString)
			{
					States enumer=java.lang.Enum.valueOf(States.class,initStateAsString);
					return buildFSM(owner,enumer);
			}
			
			static ${accessLevel} ${fsmClassName}  buildFSM(${context} owner, States enumer)
			{
					${fsmClassName}State initState = enumer.getState();
					return new ${fsmClassName}(owner,initState);
			}
	
			${accessLevel} ${fsmClassName} buildFSM(${context} owner)
			{
				return buildFSM(owner,this);
			}
	
		}
		
</#if>



<#if serialFlag>
    private void writeObject(java.io.ObjectOutputStream ostream)
                    throws java.io.IOException
                {
    <#if requiresPush>
					int size =(_stateStack == null ? 0 : _stateStack.size());
					int i;
					ostream.writeInt(size);
					for (i = 0; i < size; ++i)
					{
						ostream.writeObject(((${fsmClassName}State) _stateStack.get(i)).getName());
					}
    </#if>
                    ostream.writeObject(_state.getName());
                    return;
                }
            
            private void readObject(java.io.ObjectInputStream istream)
                    throws java.io.IOException, ClassNotFoundException
                {
    <#if requiresPush>
					int size;
			
					size = istream.readInt();
			
					if (size == 0)
					{
						_stateStack = null;
					}
					else
					{
						int i;
			
						_stateStack =
							new java.util.Stack<statemap.State>();
			
						for (i = 0; i < size; ++i)
						{
							${fsmClassName}State state;
							String stateName = (String) istream.readObject();
			<#if multimap>						
							state = java.lang.Enum.valueOf(States.class,stateName).getState();
						
			<#else>
							state = java.lang.Enum.valueOf(${mapname}.class,stateName).getState();
			</#if>						
							_stateStack.add(i, state);
						}
					}    
    </#if>
            
							String stateName = (String) istream.readObject();
			<#if multimap>						
							_state = java.lang.Enum.valueOf(States.class,stateName).getState();
						
			<#else>
							_state = java.lang.Enum.valueOf(${mapname}.class,stateName).getState();
			</#if>						
            
                    return;
                }
            
</#if>

<#if requiresPush>

	transient protected java.util.Stack<statemap.State> _stateStack;

    /**
     * Pushes the current state on top of the state stack and
     * sets the current state to {@code state}.
     * @param state The new current state.
     * @exception NullPointerException
     * if {@code state} is {@code null}.
     */
    public void pushState(statemap.State state)
    {
        if (_state == null)
        {
            throw (new NullPointerException());
        }

        if (getLog().isDebugEnabled())
        {
            getLog().debug(String.format("PUSH TO STATE   : %s [%s]",
                                     state.getName(), _name));
        }

        if (_stateStack == null)
        {
            _stateStack = new java.util.Stack<statemap.State>();
        }

        _stateStack.push(_state);
        _state = state;

        return;
    } // end of pushState(State)

    /**
     * Sets the previous state to the current state and pops
     * the top state off the stack and places it into the
     * current state.
     * if the state stack is empty.
     */
    public void popState()
    {
        if (_stateStack == null ||
            _stateStack.isEmpty() == true)
        {
            if (getLog().isDebugEnabled())
            {
                getLog().debug(
                    "POPPING ON EMPTY STATE STACK.");
            }

            throw (new RuntimeException("Empty Stack"));
        }
        else
        {
            // The pop method removes the top element
            // from the stack and returns it.
            _state = _stateStack.pop();

            if (_stateStack.isEmpty() == true)
            {
                _stateStack = null;
            }

            if (getLog().isDebugEnabled())
            {
                getLog().debug(String.format("POP TO STATE    : %s [%s]",
                                      _state.getName(), _name));
            }
        }

        return;
    } // end of popState()

    /**
     * Empties the state stack.
     */
    public void emptyStateStack()
    {
        if (_stateStack != null)
        {
            _stateStack.clear();
            _stateStack = null;
        }

        return;
    } // end of emptyStateStack()   
 </#if>

}

   