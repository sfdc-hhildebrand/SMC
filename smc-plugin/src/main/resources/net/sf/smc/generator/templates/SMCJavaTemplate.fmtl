/*
         * ex: set ro:
         * DO NOT EDIT.
         * generated by smc (http://smc.sourceforge.net/) * from file : ${srcfileBase}.sm
         */

${rawSource}

<#if packageName??>
	package ${packageName}
</#if>

        import org.slf4j.*;

<#list fsm.imports as import>
	import ${import};
</#list>

<#if reflectFlag>
	import java.util.HashMap;
	import java.util.Map;
	import java.util.Set;
	import java.util.TreeSet;
</#if>

<@compress single_line=true>
        ${accessLevel} class  ${fsmClassName}
            extends statemap.FSMContext

<#if serialFlag>
    implements java.io.Serializable
</#if>
</@compress>
        {
        private final static Logger log = LoggerFactory.getLogger(${fsmClassName}.class);
        //---------------------------------------------------------------
        // Member methods.
        //

            public Logger getLog() {return log;}

        // Generate the context class' constructor.
        ${accessLevel}  ${fsmClassName}(${context} owner)
        {
        	super(${generator.cleanStartState});
        	_owner= owner;
        <#if reflectFlag>

            <#if genericFlag>
                    _transitions = new TreeSet<String>();
            <#else>
                    _transitions = new TreeSet();
            </#if>

            <#list transitions as trans>
                _transitions.add("${trans.name}");
            </#list>

        </#if>

        }

<#--
        // Generate the second constructor which allows the
        // initial state to be dynamically set. Overrides the
        // %start specifier.
-->
        ${accessLevel}  ${fsmClassName}(${context} owner, State initState)
            {
                super (initState);
                _owner = owner;

<#if reflectFlag>

    <#if genericFlag>
            _transitions = new TreeSet<String>();
    <#else>
            _transitions = new TreeSet();
    </#if>

    <#list transitions as trans>
        _transitions.add("${trans.name}");
    </#list>

</#if>
        }

<#--
        // Generate the start abstract method which requires
        // executes the initial state's entry actions.
-->
<@compress single_line=true>
        public 
<#if syncFlag>
            synchronized 
</#if>
        void enterStartState()
</@compress>
            {
                getState().Entry(this);
                return;
            }
<#list transitions as trans>

	<#if !trans.default>
<@compress single_line=true>
        public
	
		<#if syncFlag>
				synchronized 
		</#if>

                void ${trans.name}(
    	<#list trans.parameters as param>
    	${param.type} ${param.name}
    		<#if param != trans.parameters?last>
    		,
    		</#if>
     	</#list>
		)
</@compress>
			{

				// Save away the transition name in case it is
				// need in an UndefinedTransitionException.
				_transition = "${trans.name}";
<@compress single_line=true>
				getState().${trans.name}(this
		<#list trans.parameters as param>
				,${param.name}
		</#list>
				);
</@compress>

				_transition = "";
				return;
			}
	</#if>
</#list>

<#--
        // If serialization is turned on, then generate a
        // setOwner method which allows the application class
        // to restore its ownership of the FSM.
-->

<#if serialFlag>
		// Also output the valueOf method in case developers
		// want to serialize manually.
		public ${context}State valueOf(int stateId) throws ArrayIndexOutOfBoundsException
			{
				return (_States[stateId]);
			}
</#if>

        public ${context}State getState() throws statemap.StateUndefinedException
            {
                if (_state == null)
                {
            		throw(
            			new statemap.StateUndefinedException());
                }
        		return ((${context}State) _state);
            }

            protected ${context} getOwner()
            {
                return (_owner);
            }

        public void setOwner(${context} owner)
            {
                if (owner == null)
                {
                    throw ( new NullPointerException("null owner"));
                }
                else
                {
                    _owner = owner;
                }
                return;
            }

<#if reflectFlag>
        public ${context}State[] getStates()
                {
                    return (_States);
                }
	<#if genericFlag>
		public Set<String> getTransitions()
	<#else>
		public Set	getTransitions()
	</#if>
                {
                    return (_transitions);
                }
</#if>

    	//---------------------------------------------------------------
        // Member data.
        //

        transient private ${context} _owner;

<#if reflectFlag>
    
	<#if genericFlag>
              final Set<String> _transitions;
    <#else>
              final Set  _transitions;
	</#if>
</#if>

<#if serialFlag || reflectFlag >
            String mapName;

            transient private static ${context}State[] _States = {
	<#list maps as map>
		<#list map.states as state>
			${map.name}.${state.className},
		</#list>
	</#list>
			};
			
</#if>

            @SuppressWarnings("serial") 
            ${accessLevel} static abstract class ${context}State extends statemap.State
            {
            

        // Abstract method to obtain the a state's supported
        // transitions.
<#if reflectFlag>
	<#if genericFlag>
            public abstract Map<String, Integer> getTransitions();
    <#else>
            public abstract Map getTransitions();
	</#if>
</#if>

        // Constructor.
        protected ${context}State(String name, int id)
                {
                    super (name, id);
                }
        
        protected void Entry(${fsmClassName} context) {}
        protected void Exit( ${fsmClassName} context) {}

<#list transitions as trans>
	<#if !trans.default>
<@compress single_line=true>
               protected void ${trans.name}( ${fsmClassName} context
		<#list trans.parameters as param>
				, ${param.type} ${param.name}
		</#list>
                )
</@compress>
				{

		// If this method is reached, that means that
		// this transition was passed to a state which
		// does not define the transition. Call the
		// state's default transition method.
					Default(context);

				}
                
	</#if>
</#list>
        
        
        protected void Default(${fsmClassName} context)
                {
                    if (log.isTraceEnabled())
                    {
                        log.trace("TRANSITION   : Default [" + context.getName() + "]")
                    }
                    throw ( new statemap.TransitionUndefinedException("State: " +
						context.getState().getName() +", Transition: " +
            			 context.getTransition());
                }

        // End of state class.
            //-----------------------------------------------------------
            // Member data.
            //
            }

// generating code for each map
<#list maps as map>
            <#include "SMCJavaTemplate-Map.fmtl">
</#list>

<#if serialFlag>
    private void writeObject(java.io.ObjectOutputStream ostream)
                    throws java.io.IOException
                {
    <#if requiresPush>
					int size =(_stateStack == null ? 0 : _stateStack.size());
					int i;
					ostream.writeInt(size);
					for (i = 0; i < size; ++i)
					{
						ostream.writeInt(((${context} State) _stateStack.get(i)).getId());
					}
    </#if>
                    ostream.writeInt(_state.getId());
                    return;
                }
            
            private void readObject(java.io.ObjectInputStream istream)
                    throws java.io.IOException
                {
    <#if requiresPush>
					int size;
			
					size = istream.readInt();
			
					if (size == 0)
					{
						_stateStack = null;
					}
					else
					{
						int i;
			
						_stateStack =
							new java.util.Stack<statemap.State>();
			
						for (i = 0; i < size; ++i)
						{
							_stateStack.add(i, _States[istream.readInt()]);
						}
					}    
    </#if>
            
                    _state = _States[istream.readInt()];
            
                    return;
                }
            
        }
</#if>

<#if requiresPush>

	transient protected java.util.Stack<statemap.State> _stateStack;

    /**
     * Pushes the current state on top of the state stack and
     * sets the current state to {@code state}.
     * @param state The new current state.
     * @exception NullPointerException
     * if {@code state} is {@code null}.
     */
    public void pushState(statemap.State state)
    {
        if (_state == null)
        {
            throw (new NullPointerException());
        }

        if (getLog().isDebugEnabled())
        {
            getLog().debug(String.format("PUSH TO STATE   : %s [%s]",
                                     state.getName(), _name));
        }

        if (_stateStack == null)
        {
            _stateStack = new java.util.Stack<statemap.State>();
        }

        _stateStack.push(_state);
        _state = state;

        return;
    } // end of pushState(State)

    /**
     * Sets the previous state to the current state and pops
     * the top state off the stack and places it into the
     * current state.
     * if the state stack is empty.
     */
    public void popState()
    {
        if (_stateStack == null ||
            _stateStack.isEmpty() == true)
        {
            if (getLog().isDebugEnabled())
            {
                getLog().debug(
                    "POPPING ON EMPTY STATE STACK.");
            }

            throw (new RuntimeException("Empty Stack"));
        }
        else
        {
            // The pop method removes the top element
            // from the stack and returns it.
            _state = _stateStack.pop();

            if (_stateStack.isEmpty() == true)
            {
                _stateStack = null;
            }

            if (getLog().isDebugEnabled())
            {
                getLog().debug(String.format("POP TO STATE    : %s [%s]",
                                      _state.getName(), _name));
            }
        }

        return;
    } // end of popState()

    /**
     * Empties the state stack.
     */
    public void emptyStateStack()
    {
        if (_stateStack != null)
        {
            _stateStack.clear();
            _stateStack = null;
        }

        return;
    } // end of emptyStateStack()   
 </#if>

}

   